package
{
	import flash.geom.Point;

	public class AI
	{
		public function AI()
		{
		}
		
		
		
		public static function cal( map:Array ):Array
		{
			if( ! isLegalMap(map) )
			{
				return null;
			}
			
			if( isFullMap(map) )
			{
				return map;
			}
			
			var pos:Point = getFirstEmptyPos( map );
			
			var vals:Array = getFirstEmptyVals( map , pos);
			
			trace("pos:" + pos.toString() + ",, vals: " + vals.toString());
			
			var cloneMap:Array;
			
			for( var i:int = 0; i < vals.length; i++ )
			{
//				cloneMap = cloneMat( map );
				map[pos.x][pos.y] = vals[i];
				if( cal(map) != null )
				{
					return map;
				}
				else
				{
//					map = cloneMat( cloneMap );
					return null;
				}
			}
			return null;
		}
		
		private static function getFirstEmptyVals( map:Array, pos:Point ):Array
		{
			
			var all:Array = getSerialList();
			
			var i:int;
			var j:int;
			trace("empty all: " + all.toString());
			for( i = 0; i < 9; i++ )
			{
				if( map[i][pos.y] > 0 )
				{
					delFromList( all, map[i][pos.y]);
				}
			}
			trace("empty all del  h: " + all.toString());
			
			for( j = 0; j < 9; j++)
			{
				if( map[pos.x][j] > 0 )
				{
					delFromList( all, map[pos.x][j] );
				}
			}
			trace(" v list: " + map[pos.x].toString());
			trace("empty all del v: " + all.toString());
			
			var startI:int = int( int(pos.x / 3) * 3 );
			var startJ:int = int( int(pos.y / 3) * 3 );
			for( i = startI; i < startI + 3; i++ )
			{
				for( j = startJ; j < startJ + 3; j++ )
				{
					if( map[i][j] > 0 )
					{
						delFromList( all, map[i][j] );
					}
				}
			}
			trace("empty all del mat: " + all.toString());
			
			return all;
		}
		
		private static function getFirstEmptyPos( map:Array ):Point
		{
			for( var i:int = 0; i < 9; i++ )
			{
				for( var j:int = 0; j < 9; j++ )
				{
					if( map[i][j] == 0 )
					{
						return new Point(i, j);
					}
				}
			}
			return null;
		}
		
		private static function isFullMap( map:Array ):Boolean
		{
			for( var i:int = 0; i < 9; i++ )
			{
				for( var j:int = 0; j < 9; j++ )
				{
					if( map[i][j] == 0 )
					{
						return false;
					}
				}
			}
			return true;
		}
		
		private static function isLegalMap( map:Array ):Boolean
		{
			if( map == null || map.length == 0 )
			{
				return false;
			}
			
			var i:int;
			var j:int;
			for( i = 0; i <= 6; i = i + 3)
			{
				for( j = 0; j <= 6; j = j + 3)
				{
					if( ! isLegalMat(map, i, j) )
					{
						return false;
					}
				}
			}
			
			for( i = 0; i < 9; i++ )
			{
				if( ! isLegalH(map, i ) )
				{
					return false;
				}
			}
			
			for( j = 0; j < 9; j++)
			{
				if( ! isLegalV(map, j) )
				{
					return false;
				}
			}
			
			return true;
		}
		
		private static function isLegalMat( map:Array, startI:int, startJ:int ):Boolean
		{
			var all:Array = getSerialList();
			for(var i:int = startI; i < startI + 3; i++)
			{
				for( var j:int = startJ; j < startJ + 3; j++ )
				{
					if( map[i][j] > 0 )
					{
						if( ! delFromList(all, map[i][j]) )
						{
							trace("illegal mat");
							return false;
						}
					}
					
				}
			}
			return true;
		}
		
		private static function isLegalH( map:Array, i:int):Boolean
		{
			var all:Array = getSerialList();
			for( var j:int = 0; j < 9; j++ )
			{
				if( map[i][j] > 0 )
				{
					if( ! delFromList(all, map[i][j]) )
					{
						trace("illegal h");
						return false;
					}
				}
			}
			return true;
		}
		
		private static function isLegalV( map:Array, j:int):Boolean
		{
			var all:Array = getSerialList();
			for( var i:int = 0; i < 9; i++ )
			{
				if( map[i][j] > 0 )
				{
					if( ! delFromList(all, map[i][j]) )
					{
						trace("illegal v");
						return false;
					}
				}
			}
			return true;
		}
		
		private static function delFromList( arr:Array, target:int ):Boolean
		{
			for(var i:int = 0; i < arr.length; i++ )
			{
				if( arr[i] == target )
				{
					arr.splice(i, 1);
					return true;
				}
			}
			return false;
		}
		
		private static function getSerialList():Array
		{
			var arr:Array = [];
			for( var i:int = 1; i <= 9; i++)
			{
				arr.push( i );
			}
			return arr;
		}
		
		private static function cloneMat( map:Array ):Array
		{
			var copy:Array = [];
			for( var i:int = 0; i < map.length; i++ )
			{
				copy[i] = [];
				for( var j:int = 0; j < map[i].length; j++)
				{
					copy[i][j] = map[i][j];
				}
			}
			return copy;
		}
	}
}